<!doctype html>
<html lang="da">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Labubu Roguelike</title>
<meta name="description" content="Et lille browser-roguelike med din trofaste bamse Labubu.">
<meta property="og:title" content="Labubu Roguelike">
<meta property="og:description" content="Et lille browser-roguelike med din trofaste bamse Labubu.">
<meta property="og:type" content="website">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256'><text y='0.9em' font-size='200'>üß∏</text></svg>">
<style>
  :root { --bg:#0e0e11; --fg:#eee; --muted:#aaa; --accent:#57d; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:flex;align-items:center;justify-content:center;min-height:100vh;padding:20px;box-sizing:border-box}
  .card{max-width:820px;width:100%;background:#14141a;border:1px solid #20202a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.45);overflow:hidden}
  .hero{padding:28px 28px 10px;border-bottom:1px solid #1e1e28}
  .hero h1{margin:.2em 0 .1em;font-size:28px}
  .hero p{margin:.4em 0 0;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;padding:16px}
  .panel{background:#0f0f15;border:1px solid #1d1d25;border-radius:12px;padding:14px}
  .panel h2{font-size:16px;margin:0 0 8px;color:#cfd8ff}
  button.primary{appearance:none;background:var(--accent);color:white;border:none;border-radius:10px;padding:14px 18px;font-weight:600;font-size:15px;cursor:pointer}
  button.primary:active{transform:translateY(1px)}
  .kbd{display:inline-block;border:1px solid #343445;background:#14141a;border-radius:6px;padding:2px 6px;margin:0 2px;color:#cfe}
  .topbar{display:flex;align-items:center;gap:8px;padding:8px;border-bottom:1px solid #1e1e28;background:#13131a;position:sticky;top:0;z-index:5}
  .topbar .spacer{flex:1}
  #game{display:block;margin:8px auto;border:1px solid #1e1e28;background:#000}
  .hud{display:flex;gap:14px;justify-content:center;margin:6px 0 14px;color:#cfd8ff}
  .pill{background:#0f2036;border:1px solid #1a3a68;padding:6px 10px;border-radius:999px}
  .muted{color:#aab}
  .hidden{display:none !important}
  .note{font-size:12px;color:#9aa}
</style>
</head>
<body>
<div class="wrap" id="landing">
  <div class="card">
    <div class="hero">
      <h1>Labubu Roguelike üß∏‚öîÔ∏è</h1>
      <p>Proceduriske baner, simple fjender ‚Äì og din bamseven <strong>Labubu</strong> som giver mod og +1 slagkraft ved siden af dig.</p>
    </div>
    <div class="grid">
      <div class="panel">
        <h2>Styring</h2>
        <p><span class="kbd">WASD</span> / <span class="kbd">Piletaster</span> Bev√¶gelse</p>
        <p><span class="kbd">F</span> Sl√• ‚Ä¢ <span class="kbd">G</span> Saml op ‚Ä¢ <span class="kbd">Enter</span> Ned ad trappen</p>
        <p><span class="kbd">L</span> Labubu f√∏lger/venter ‚Ä¢ <span class="kbd">H</span> Kram Labubu (siger ‚Äúla bu bu‚Äù)</p>
        <p class="note">Tip: F√∏rste klik aktiverer lyd (browser-krav).</p>
        <button class="primary" id="btnPlay">Spil nu</button>
      </div>
      <div class="panel">
        <h2>Om spillet</h2>
        <p>En enkelt HTML-fil, klar til GitHub Pages. Ingen eksterne assets.</p>
        <p class="muted">Bygget til undervisning/leg ‚Äì kode er kommenteret og kan udvides.</p>
      </div>
    </div>
  </div>
</div>

<div class="topbar hidden" id="topbar">
  <strong>Labubu Roguelike</strong>
  <span class="spacer"></span>
  <button class="primary" id="btnHug">Kram bamse ü§ó</button>
  <button class="primary" id="btnFollow">Bamse f√∏lger</button>
</div>

<canvas id="game" width="800" height="600" class="hidden"></canvas>
<div class="hud hidden" id="hud">
  <div class="pill" id="statHP">HP: 10</div>
  <div class="pill" id="statATK">ATK: 2</div>
  <div class="pill" id="statFLOOR">Level: 1</div>
  <div class="pill" id="statLAB">Labubu: f√∏lger</div>
</div>

<script>
// === Simple Roguelike Engine (compact & commented) =========================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const TILE = 20, COLS = Math.floor(W/TILE), ROWS = Math.floor(H/TILE);

const landing = document.getElementById('landing');
const topbar = document.getElementById('topbar');
const hud = document.getElementById('hud');
const btnPlay = document.getElementById('btnPlay');
const btnHug = document.getElementById('btnHug');
const btnFollow = document.getElementById('btnFollow');

const statHP = document.getElementById('statHP');
const statATK = document.getElementById('statATK');
const statFLOOR = document.getElementById('statFLOOR');
const statLAB = document.getElementById('statLAB');

// World tiles
const WALL = 1, FLOOR = 0, STAIRS = 2, KEY = 3, POTION = 4;
// Colors
const C = {
  floor: '#1a1a1f', wall: '#2a2a33', stairs: '#6ad', key:'#fc3', pot:'#6f6',
  player:'#9cf', enemy:'#f77', labubu:'#f8a', fog:'#000000aa', seen:'#0b0b10'
};

// Game state
let map, seen, player, enemies, items, stairs, floor=1;

// Labubu companion
const labubu = {
  x:0,y:0, following:true,
  speak(){ say("la bu bu"); },
};

// Simple speech using SpeechSynthesis (no external files)
function say(text){
  try{
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'da-DK';
    u.rate = 1.0;
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  }catch(e){/* ignore */}
}

btnHug.onclick = ()=>{ labubu.speak(); flashNote("Du krammer Labubu. ‚ù§Ô∏è"); };
btnFollow.onclick = ()=>{ labubu.following = !labubu.following; updateHUD(); };

btnPlay.onclick = ()=>{
  landing.classList.add('hidden');
  topbar.classList.remove('hidden');
  canvas.classList.remove('hidden');
  hud.classList.remove('hidden');
  newGame();
  draw();
};

function newGame(){
  floor = 1;
  genLevel();
  player = {x: stairs.spawn.x, y: stairs.spawn.y, hp:10, atk:2, keys:0};
  labubu.x = player.x+1; labubu.y = player.y; labubu.following = true;
  updateHUD();
}

// Level generation: rooms + corridors, very compact
function genLevel(){
  map = Array.from({length:ROWS},()=>Array(COLS).fill(WALL));
  seen = Array.from({length:ROWS},()=>Array(COLS).fill(false));
  const rooms=[];
  const R=8+randInt(8);
  for(let i=0;i<R;i++){
    const w=4+randInt(6), h=4+randInt(6);
    const x=1+randInt(COLS-w-2), y=1+randInt(ROWS-h-2);
    rooms.push({x,y,w,h});
    carveRect(x,y,w,h);
  }
  // corridors
  rooms.sort((a,b)=>a.x-b.x);
  for(let i=0;i<rooms.length-1;i++){
    const a=rooms[i], b=rooms[i+1];
    const y = a.y + Math.floor(a.h/2);
    for(let x=Math.min(a.x+b.w, b.x); x<=Math.max(a.x+a.w, b.x); x++) map[y][x]=FLOOR;
    const x = b.x + Math.floor(b.w/2);
    for(let yy=Math.min(a.y+a.h, b.y); yy<=Math.max(a.y, b.y+b.h); yy++) map[yy][x]=FLOOR;
  }
  // Place stairs, items, enemies, spawn
  const start = rooms[0], end = rooms[rooms.length-1];
  stairs = {
    up:{x: end.x+Math.floor(end.w/2), y: end.y+Math.floor(end.h/2)},
    spawn:{x: start.x+Math.floor(start.w/2), y: start.y+Math.floor(start.h/2)}
  };
  map[stairs.up.y][stairs.up.x] = STAIRS;
  items = [];
  for(let i=0;i<5;i++){ placeRandom(KEY); }
  for(let i=0;i<4;i++){ placeRandom(POTION); }
  enemies = [];
  for(let i=0;i<7+floor;i++){ enemies.push(makeEnemy()); }
}

function carveRect(x,y,w,h){
  for(let j=y;j<y+h;j++) for(let i=x;i<x+w;i++) map[j][i]=FLOOR;
}

function placeRandom(type){
  let x,y;
  for(let n=0;n<999;n++){
    x=randInt(COLS); y=randInt(ROWS);
    if(map[y][x]===FLOOR){ map[y][x]=type; return; }
  }
}

function makeEnemy(){
  let x,y;
  while(true){
    x=randInt(COLS); y=randInt(ROWS);
    if(map[y][x]===FLOOR && dist(x,y,stairs.spawn.x,stairs.spawn.y)>8) break;
  }
  return {x,y,hp:3+Math.floor(floor/2), atk:1+Math.floor(floor/3)};
}

// Helpers
function randInt(n){ return Math.floor(Math.random()*n); }
function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

// Field of view (simple ray-march)
function computeFOV(px,py, radius=8){
  const visible = Array.from({length:ROWS},()=>Array(COLS).fill(false));
  visible[py][px]=true;
  const rays = 180;
  for(let r=0;r<rays;r++){
    const a = (Math.PI*2)*r/rays;
    let x=px+0.5, y=py+0.5;
    for(let t=0;t<radius*TILE;t++){
      x+=Math.cos(a)*0.1;
      y+=Math.sin(a)*0.1;
      const tx = Math.floor(x), ty = Math.floor(y);
      if(tx<0||ty<0||tx>=COLS||ty>=ROWS) break;
      visible[ty][tx]=true;
      if(map[ty][tx]===WALL) break;
    }
  }
  return visible;
}

// Input
const keys = {};
window.addEventListener('keydown',e=>{
  keys[e.key]=true;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  handleKey(e.key);
});
window.addEventListener('keyup',e=>{ keys[e.key]=false; });

function handleKey(k){
  if(landing && !landing.classList.contains('hidden')) return;
  if(k==='ArrowUp'||k==='w'||k==='W') tryMove(0,-1);
  if(k==='ArrowDown'||k==='s'||k==='S') tryMove(0,1);
  if(k==='ArrowLeft'||k==='a'||k==='A') tryMove(-1,0);
  if(k==='ArrowRight'||k==='d'||k==='D') tryMove(1,0);
  if(k==='f'||k==='F') attack();
  if(k==='g'||k==='G') pickup();
  if(k==='Enter'){ tryStairs(); }
  if(k==='l'||k==='L'){ labubu.following=!labubu.following; updateHUD(); }
  if(k==='h'||k==='H'){ labubu.speak(); flashNote("Du krammer Labubu. ‚ù§Ô∏è"); }
  draw();
}

function tryMove(dx,dy){
  const nx = clamp(player.x+dx,0,COLS-1), ny=clamp(player.y+dy,0,ROWS-1);
  if(map[ny][nx]!==WALL){
    player.x=nx; player.y=ny;
    // Labubu follows if enabled
    if(labubu.following){
      const lx = labubu.x, ly=labubu.y;
      if(dist(lx,ly,player.x,player.y)>1.5){
        // step towards player
        const sdx = Math.sign(player.x - lx);
        const sdy = Math.sign(player.y - ly);
        const tx = lx + (Math.abs(player.x-lx)>Math.abs(player.y-ly)? sdx:0);
        const ty = ly + (Math.abs(player.x-lx)>Math.abs(player.y-ly)? 0:sdy);
        if(map[ty] && map[ty][tx]!==WALL){ labubu.x=tx; labubu.y=ty; }
      }
    }
    // Enemies act
    enemiesAct();
  }
}

function attack(){
  const atk = player.atk + (adjacent(player,labubu)?1:0);
  const targets = enemies.filter(e=>adjacent(e,player));
  if(targets.length){
    const t = targets[0];
    t.hp -= atk;
    flashNote(`Du rammer for ${atk}.`);
    if(t.hp<=0){
      enemies = enemies.filter(e=>e!==t);
      flashNote("Fjenden falder!");
    }
  }else{
    flashNote("Du svinger i luften.");
  }
}

function pickup(){
  const t = map[player.y][player.x];
  if(t===KEY){ player.keys++; map[player.y][player.x]=FLOOR; flashNote("Du finder en n√∏gle. La bu bu!"); labubu.speak(); }
  if(t===POTION){ player.hp = Math.min(player.hp+3, 12); map[player.y][player.x]=FLOOR; flashNote("Du drikker en potion (+3 HP)."); }
  updateHUD();
}

function tryStairs(){
  if(player.x===stairs.up.x && player.y===stairs.up.y){
    if(player.keys>0){
      player.keys--;
      floor++;
      genLevel();
      player.x = stairs.spawn.x; player.y = stairs.spawn.y;
      labubu.x = player.x+1; labubu.y=player.y;
      flashNote("Ned til n√¶ste level. La bu bu!");
      labubu.speak();
      updateHUD();
      draw();
    }else{
      flashNote("Du mangler en n√∏gle.");
    }
  }
}

function adjacent(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)===1; }

function enemiesAct(){
  for(const e of enemies){
    // Chase if close
    if(dist(e.x,e.y,player.x,player.y)<7){
      const dx = Math.sign(player.x - e.x);
      const dy = Math.sign(player.y - e.y);
      const tx = e.x + (Math.random()<0.5?dx:0);
      const ty = e.y + (tx===e.x? dy: e.y);
      if((tx!==e.x||ty!==e.y) && map[ty] && map[ty][tx]!==WALL){
        e.x=tx; e.y=ty;
      }
    }else{
      // Wander
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const [dx,dy]=dirs[randInt(dirs.length)];
      const tx=e.x+dx, ty=e.y+dy;
      if(map[ty] && map[ty][tx]!==WALL) { e.x=tx; e.y=ty; }
    }
    // Damage if adjacent
    if(adjacent(e,player)){
      player.hp -= e.atk;
      flashNote(`Du bliver ramt (${e.atk}).`);
      if(player.hp<=0){ gameOver(); return; }
    }
  }
  updateHUD();
}

// UI updates
let noteTimer=0, noteText="";
function flashNote(t){
  noteText=t; clearTimeout(noteTimer);
  noteTimer=setTimeout(()=>{ noteText=""; draw(); }, 1200);
  draw();
}

function updateHUD(){
  statHP.textContent = `HP: ${player?.hp ?? 0}`;
  const buff = (player && adjacent(player,labubu))? 1:0;
  statATK.textContent = `ATK: ${(player?.atk ?? 0)}${buff?` (+${buff} m. Labubu)`:''}`;
  statFLOOR.textContent = `Level: ${floor}`;
  statLAB.textContent = `Labubu: ${labubu.following? 'f√∏lger':'venter'}`;
  btnFollow.textContent = labubu.following? 'Bamse f√∏lger' : 'Bamse venter';
}

// Drawing
function draw(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  if(!player) return;
  const visible = computeFOV(player.x,player.y, 9);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(visible[y][x]) seen[y][x]=true;
      const t = map[y][x];
      // background / seen / fog
      if(seen[y][x]){
        ctx.fillStyle = visible[y][x]? C.floor : C.seen;
        if(t===WALL) ctx.fillStyle = visible[y][x]? C.wall : '#15151b';
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        // content
        if(visible[y][x]){
          if(t===STAIRS){ drawGlyph(x,y,'‚á©',C.stairs); }
          else if(t===KEY){ drawGlyph(x,y,'üîë','#ffc83d'); }
          else if(t===POTION){ drawGlyph(x,y,'üß™','#8f8'); }
        }
      }
      if(!visible[y][x] && !seen[y][x]){
        ctx.fillStyle = C.fog; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
      }
    }
  }
  // Enemies/items
  for(const e of enemies){
    if(visible[e.y]?.[e.x]) drawCircle(e.x,e.y, C.enemy);
  }
  // Labubu & Player
  if(visible[labubu.y]?.[labubu.x]) drawCircle(labubu.x,labubu.y, C.labubu, 6); // smaller
  drawCircle(player.x,player.y, C.player);
  // Notes
  if(noteText){
    ctx.fillStyle='rgba(0,0,0,.5)';
    ctx.fillRect(0,H-36,W,36);
    ctx.fillStyle='#fff';
    ctx.font='16px system-ui, sans-serif';
    ctx.textAlign='center';
    ctx.fillText(noteText, W/2, H-14);
    ctx.textAlign='left';
  }
}

function drawCircle(x,y,color, r=8){
  const cx = x*TILE+TILE/2, cy=y*TILE+TILE/2;
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.fill();
}

function drawGlyph(x,y,ch,color='#fff'){
  ctx.fillStyle=color; ctx.font='16px system-ui, sans-serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(ch, x*TILE+TILE/2, y*TILE+TILE/2+1);
  ctx.textAlign='left'; ctx.textBaseline='alphabetic';
}

function gameOver(){
  flashNote("Du faldt i kamp. Tryk R for at starte forfra.");
  window.addEventListener('keydown',resetOnce,{once:true});
  function resetOnce(e){ if(e.key.toLowerCase()==='r'){ newGame(); draw(); } else { window.addEventListener('keydown',resetOnce,{once:true}); } }
}

</script>
</body>
</html>
